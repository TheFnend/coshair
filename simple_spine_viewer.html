<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Simple Spine Model Viewer</title>
  
  <!-- PIXI.js and Spine dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@6.2.2/dist/browser/pixi.js"
          integrity="sha256-AiXDYWt7rqC7JuOBLIvL2GuRGjjE1mvYepH56aycTPc=" crossorigin="anonymous"></script>
  <!-- 模型描边使用内联 Outline Shader 实现，无需外部过滤器 -->
  <script src="naganeko.pages.dev/chibi-gif/js2/pixi-spine-3.8.umd_all-3.8@3.0.16.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
      font-family: 'Arial', sans-serif;
      overflow-x: hidden;
    }
    
    #main-content {
      padding: 50px 20px;
      text-align: center;
      min-height: 70vh;
    }
    
    h1 {
      color: #333;
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    p {
      color: #666;
      font-size: 1.2em;
      max-width: 600px;
      margin: 0 auto;
      line-height: 1.6;
    }
    
    #spine-container {
      position: fixed;
      top: 0px;
      left: 0px;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      z-index: 1000;
    }
    
    #spine-container canvas {
      border-radius: 12px;
    }
    
    .loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 14px;
      text-align: center;
    }
    
    .error-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.1);
      border: 1px solid #ff6b6b;
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      text-align: center;
      color: #d63031;
      max-width: 250px;
    }
  </style>
</head>
<body>
  <div id="main-content">
    <h1>Simple Spine Model Viewer</h1>
    <p>欢迎来到简单的Spine模型查看器！这是一个干净简洁的页面，右下角会显示来自model文件夹的Spine动画模型。</p>
  </div>
  
  <div id="controls" style="margin-bottom: 10px; position: fixed; bottom: 20px; left: 20px; width: 300px; text-align: center; z-index: 1100;">
    <div style="margin-bottom: 8px;">
      <select id="model-select" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
          <option value="">选择模型...</option>
          <option value="003_kalts">003_kalts</option>
          <option value="003_kalts_boc#6">003_kalts_boc#6</option>
          <option value="1000_gopro">1000_gopro</option>
          <option value="148_nearl">148_nearl</option>
          <option value="dyn_illust_003_kalts_boc#6">dyn_illust_003_kalts_boc#6</option>
        </select>
    </div>
    <div style="margin-bottom: 8px;">
      <select id="animation-select" style="margin-right: 10px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
        <option value="">选择动作...</option>
      </select>
      <button id="play-pause-btn" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; background: #fff; cursor: pointer;">播放/暂停</button>
    </div>
    <div id="model-info" style="font-size: 12px; color: #666; text-align: left; padding: 5px; background: #f9f9f9; border-radius: 4px; display: none;">
      <div>模型: <span id="current-model">未选择</span></div>
      <div>状态: <span id="model-status">等待选择</span></div>
    </div>
  </div>
  
  <div id="spine-container">
    <div class="loading-text">正在加载模型...</div>
  </div>
  
  <script>
    // 创建PIXI应用
    const app = new PIXI.Application({
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: 0x000000,
      backgroundAlpha: 0,
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true
    });
    
    // 全局变量
    const container = document.getElementById('spine-container');
    const loadingText = container.querySelector('.loading-text');
    let currentSpine = null;
    let isPlaying = true;
    let moveDirection = 1; // 1为向右，-1为向左
    let moveSpeed = 1; // 移动速度
    let isMoving = false;
    let pauseTimer = 0; // 暂停计时器
    let pauseDuration = 0; // 暂停持续时间
    let isPaused = false; // 是否正在暂停
    let originalAnimation = ''; // 原始移动动画名称
    let isMouseInteracting = false; // 是否正在鼠标交互
    let mouseInteractAnimation = '';
    // 拖拽/下落/高亮相关全局变量
    let isDragging = false;
    let isFalling = false;
    let isOnGround = true;
    let fallSpeed = 0;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let dragOutlineFilter = null;
    
    const gravity = 2200; // px/s^2，重力加速度（基于 dt 时间步长）
    // 惯性物理参数与状态
    let vx = 0, vy = 0; // 速度（px/s）
    const airFriction = 2.0;       // 空气阻力（越大衰减越快）
    const staticFriction = 900.0;  // 地面静摩擦（px/s^2 等效）
    const resilience = 0.3;        // 水平弹性系数（0~1），撞墙后反弹比例
    const droppedThreshold = 10.0;  // 触发“落地一次”的最小高度（px）
    const maxSpeedX = 2500.0;       // 水平最大速度限制
    const maxSpeedY = 3500.0;       // 垂直最大速度限制
    let dropStartY = null;          // 记录离地或抛出时的起始高度
    const pointerSamples = [];      // 拖拽采样用于释放瞬时速度计算

    function pushPointerSample(x, y, tMs) {
      // 仅保留最近 ~160ms 的样本
      pointerSamples.push({ x, y, t: tMs });
      const cutoff = tMs - 160;
      while (pointerSamples.length && pointerSamples[0].t < cutoff) {
        pointerSamples.shift();
      }
    }
    function computeReleaseVelocity() {
      const n = pointerSamples.length;
      if (n < 2) return { vx: 0, vy: 0 };
      const end = pointerSamples[n - 1];
      // 找到与末端时间差至少 ~60ms 的较早样本，提高稳健性
      let i = n - 2;
      while (i >= 0 && (end.t - pointerSamples[i].t) < 60) i--;
      i = Math.max(0, i);
      const start = pointerSamples[i];
      const dt = Math.max(1, end.t - start.t) / 1000; // s
      return {
        vx: (end.x - start.x) / dt,
        vy: (end.y - start.y) / dt
      };
    }
    
    // 模型配置映射
    const modelConfigs = {
      '003_kalts': {
        name: '003_kalts',
        skelFile: 'model/003_kalts/build_char_003_kalts.skel',
        displayName: 'Kalts'
      },
      '003_kalts_boc#6': {
        name: '003_kalts_boc#6',
        skelFile: 'model/003_kalts_boc#6/build_char_003_kalts_boc#6.skel',
        displayName: 'Kalts BOC#6',
        allowUpscale: true
      },
      '1000_gopro': {
        name: '1000_gopro',
        skelFile: 'model/1000_gopro/enemy_1000_gopro.skel',
        displayName: 'Gopro'
      },
      'dyn_illust_003_kalts_boc#6': {
        name: 'dyn_illust_003_kalts_boc#6',
        skelFile: 'model/dyn_illust_003_kalts_boc#6/dyn_illust_char_003_kalts_boc#6.skel',
        displayName: 'Kalts BOC#6 (Dynamic)'
      },
      '148_nearl': {
        name: '148_nearl',
        skelFile: 'model/148_nearl/build_char_148_nearl.skel',
        displayName: 'Nearl'
      }
    };
    
    // 编码URL路径中的每个段，避免如#等特殊字符导致加载失败
    function encodePathSegments(path) {
      if (!path) return path;
      return path.split('/').map(encodeURIComponent).join('/');
    }
    
    // 更新模型信息显示
    function updateModelInfo(modelName, status) {
      const modelInfo = document.getElementById('model-info');
      const currentModelSpan = document.getElementById('current-model');
      const modelStatusSpan = document.getElementById('model-status');
      
      if (modelName) {
        const config = modelConfigs[modelName];
        currentModelSpan.textContent = config ? config.displayName : modelName;
        modelInfo.style.display = 'block';
      } else {
        currentModelSpan.textContent = '未选择';
        modelInfo.style.display = 'none';
      }
      
      modelStatusSpan.textContent = status;
    }
    
    // 清理当前模型
    function clearCurrentModel() {
      if (currentSpine) {
        stopMoving();
        // 移除鼠标点击与拖拽事件监听器
        currentSpine.off('click', handleMouseClick);
        currentSpine.off('pointerdown', startDrag);
        app.stage.removeChild(currentSpine);
        currentSpine.destroy();
        currentSpine = null;
      }
      // 重置交互与拖拽/下落状态
      isMouseInteracting = false;
      isDragging = false;
      isFalling = false;
      isOnGround = true;
      fallSpeed = 0;
      // 清理拖拽高亮（移除描边滤镜）
      if (currentSpine && currentSpine.filters) {
        currentSpine.filters = currentSpine.filters.filter(f => f !== dragOutlineFilter);
      }
      dragOutlineFilter = null;
      // 清空动画选择器
      const animationSelect = document.getElementById('animation-select');
      animationSelect.innerHTML = '<option value="">选择动作...</option>';
    }
    
    // 移动控制函数
    function startMoving() {
      if (!currentSpine || !isMoving) return;
      
      app.ticker.add(moveModel);
    }
    
    function stopMoving() {
      isMoving = false;
      isPaused = false;
      app.ticker.remove(moveModel);
    }
    
    function startRandomPause() {
      if (!currentSpine || isPaused || isMouseInteracting) return;
      
      // 不需要保存当前动画，始终恢复到move动画
      
      // 随机选择暂停动画
      const pauseAnimations = ['interact', 'relax', 'sleep', 'idle', 'stand'];
      const availableAnimations = currentSpine.state.data.skeletonData.animations.filter(anim => 
        pauseAnimations.some(pauseAnim => anim.name.toLowerCase().includes(pauseAnim.toLowerCase()))
      );
      
      if (availableAnimations.length > 0) {
        const randomAnim = availableAnimations[Math.floor(Math.random() * availableAnimations.length)];
        currentSpine.state.setAnimation(0, randomAnim.name, false); // 播放一次，不循环
        
        isPaused = true;
        console.log(`随机暂停，播放动画: ${randomAnim.name}`);
        
        // 设置动画完成后的回调
        currentSpine.state.addListener({
          complete: function(entry) {
            if (entry.animation.name === randomAnim.name && isPaused) {
              // 随机动画播放完成，恢复移动动画
              isPaused = false;
              pauseTimer = 0;
              if (originalAnimation && currentSpine.state.data.skeletonData.findAnimation(originalAnimation)) {
                currentSpine.state.setAnimation(0, originalAnimation, true);
                console.log(`随机动画完成，恢复移动动画: ${originalAnimation}`);
              }
              // 移除监听器
              currentSpine.state.clearListeners();
            }
          }
        });
      }
    }
    
    // 鼠标点击交互函数
    function handleMouseClick() {
      if (!currentSpine || isMouseInteracting) return;
      // 仅落地后允许触发交互
      if (!isOnGround) return;
      // 不需要保存当前动画，始终恢复到move动画
      const interactAnimations = currentSpine.state.data.skeletonData.animations.filter(anim => 
        anim.name.toLowerCase().includes('interact')
      );
      if (interactAnimations.length > 0) {
        const interactAnim = interactAnimations[0];
        currentSpine.state.setAnimation(0, interactAnim.name, false);
        mouseInteractAnimation = interactAnim.name;
        console.log(`鼠标点击，播放动画: ${interactAnim.name}`);
        isMouseInteracting = true;
        isPaused = false;
        pauseTimer = 0;
        currentSpine.state.addListener({
          complete: function(entry) {
            if (entry.animation.name === interactAnim.name && isMouseInteracting) {
              isMouseInteracting = false;
              if (originalAnimation && currentSpine.state.data.skeletonData.findAnimation(originalAnimation)) {
                currentSpine.state.setAnimation(0, originalAnimation, true);
                console.log(`interact动画完成，恢复移动动画: ${originalAnimation}`);
              }
              currentSpine.state.clearListeners();
            }
          }
        });
      }
    }
    // 拖拽高亮绘制与移除（使用自定义 Outline Shader 实现模型描边）
    const dragOutlineShaderFrag = `
      precision mediump float;
      varying vec2 vTextureCoord;
      uniform sampler2D uSampler;
      uniform vec2 pixelSize;    // 1.0 / screen size
      uniform float thickness;   // 描边粗细
      uniform vec4 outlineColor; // RGBA 颜色
      void main(void) {
        vec4 base = texture2D(uSampler, vTextureCoord);
        float a = base.a;
        float maxAlpha = 0.0;
        // 采样邻域 8 个方向
        for (int x = -1; x <= 1; x++) {
          for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            vec2 offset = vec2(float(x), float(y)) * pixelSize * thickness;
            vec4 s = texture2D(uSampler, vTextureCoord + offset);
            maxAlpha = max(maxAlpha, s.a);
          }
        }
        float outline = clamp(maxAlpha - a, 0.0, 1.0);
        // 若当前像素本身不可见但邻域可见 -> 绘制描边色；否则保持原色
        vec4 color = (a < 0.01 && outline > 0.0)
          ? vec4(outlineColor.rgb, outlineColor.a * outline)
          : base;
        gl_FragColor = color;
      }
    `;
    function ensureDragOutlineFilter() {
      if (!dragOutlineFilter) {
        dragOutlineFilter = new PIXI.Filter(undefined, dragOutlineShaderFrag, {
          pixelSize: new Float32Array([1 / app.screen.width, 1 / app.screen.height]),
          thickness: 20.0,
          outlineColor: new Float32Array([1.0, 1.0, 0.0, 1.0]) // 更亮的黄色 #FFFF00
         });
      }
      return dragOutlineFilter;
    }
    // 拖拽高亮绘制与移除（使用自定义 Outline Shader 实现模型描边）
    function updateDragHighlight() {
      if (!currentSpine) return;
      const filter = ensureDragOutlineFilter();
      const filters = currentSpine.filters || [];
      if (!filters.includes(filter)) {
        currentSpine.filters = [...filters, filter];
      }
    }
     function removeDragHighlight() {
       if (!currentSpine) return;
       if (currentSpine.filters && currentSpine.filters.length) {
         currentSpine.filters = currentSpine.filters.filter(f => f !== dragOutlineFilter);
       }
     }
    // 开始拖拽
    function startDrag(event) {
      if (!currentSpine) return;
      isDragging = true;
      isOnGround = false;
      isFalling = false;
      fallSpeed = 0;
      // 拖拽开始时清零物理速度并记录起始高度
      vx = 0; vy = 0;
      dropStartY = currentSpine ? currentSpine.y : null;
      // 初始化采样
      pointerSamples.length = 0;
      const pos = event.data.getLocalPosition(app.stage);
      dragOffsetX = pos.x - currentSpine.x;
      dragOffsetY = pos.y - currentSpine.y;
      pushPointerSample(pos.x, pos.y, (self.performance ? performance.now() : Date.now()));
      updateDragHighlight();
    }
    // 拖拽移动
    function onDragMove(event) {
      if (!isDragging || !currentSpine) return;
      const pos = event.data.getLocalPosition(app.stage);
      currentSpine.x = pos.x - dragOffsetX;
      currentSpine.y = pos.y - dragOffsetY;
      pushPointerSample(pos.x, pos.y, (self.performance ? performance.now() : Date.now()));
      updateDragHighlight();
    }
    // 结束拖拽 -> 开始下落
    function endDrag() {
      if (!isDragging) return;
      isDragging = false;
      removeDragHighlight();
      isFalling = true;
      fallSpeed = 0;
      // 根据最近拖拽采样，计算释放瞬时速度作为初速度
      const v = computeReleaseVelocity();
      vx = v.vx;
      vy = v.vy;
      // 离地自由运动（若向上抛则 vy 为负，向下为正）
      isOnGround = false;
      isFalling = false;
      fallSpeed = 0;
      // 记录抛出开始高度用于“落地一次”阈值判断
      dropStartY = currentSpine ? currentSpine.y : null;
    }
        function moveModel() {
          if (!currentSpine || !isMoving) return;
          // 拖拽中不进行物理更新
          if (isDragging) return;
    
          const dt = app.ticker && typeof app.ticker.deltaMS === 'number' ? (app.ticker.deltaMS / 1000) : (1 / 60);
    
          // 受力：重力（离地才生效）
          if (!isOnGround) {
            vy += gravity * dt;
          }
    
          // 空气阻力：对速度做指数式衰减（简单线性近似）
          const air = Math.max(0, 1 - airFriction * dt);
          vx *= air;
          if (!isOnGround) vy *= air;
    
          // 地面静摩擦：落地后让水平速度逐渐衰减至 0
          if (isOnGround) {
            const sign = Math.sign(vx);
            const mag = Math.max(0, Math.abs(vx) - staticFriction * dt);
            vx = sign * mag;
          }
    
          // 限速
          vx = Math.max(-maxSpeedX, Math.min(maxSpeedX, vx));
          vy = Math.max(-maxSpeedY, Math.min(maxSpeedY, vy));
    
          // 位置积分
          currentSpine.x += vx * dt;
          currentSpine.y += vy * dt;
    
          // 垂直边界（顶部与地面）
          const groundY = app.screen.height;
          if (currentSpine.y >= groundY) {
            // 触地：检查"落地一次"阈值
            if (!isOnGround && dropStartY != null) {
              const droppedHeight = groundY - dropStartY;
              if (droppedHeight >= droppedThreshold) {
                // 可在此触发一次性落地事件或动画
               // console.log('Dropped once, height =', droppedHeight);
              }
            }
            currentSpine.y = groundY;
            vy = 0;
            isOnGround = true;
          } else if (currentSpine.y < 0) {
            currentSpine.y = 0;
            vy = 0;
            isOnGround = false;
          } else {
            isOnGround = false;
          }
    
          // 水平边界 + 弹性反弹
          if (currentSpine.x <= 0) {
            currentSpine.x = 0;
            vx = -vx * resilience;
          } else if (currentSpine.x >= app.screen.width) {
            currentSpine.x = app.screen.width;
            vx = -vx * resilience;
          }
    
          // 根据速度朝向翻转朝向
          if (currentSpine.skeleton) {
            if (vx > 5) currentSpine.skeleton.scaleX = Math.abs(currentSpine.skeleton.scaleX);
            else if (vx < -5) currentSpine.skeleton.scaleX = -Math.abs(currentSpine.skeleton.scaleX);
          }
    
          // 几乎静止时（落地），保留现有"随机暂停"趣味
          if (isOnGround && Math.abs(vx) < 5 && Math.abs(vy) < 5) {
            if (!isMouseInteracting && !isPaused && Math.random() < 0.003) {
              startRandomPause();
            }
          }
        }
    // 加载Spine模型
    async function loadSpineModel(modelName) {
      if (!modelName || !modelConfigs[modelName]) {
        console.error('无效的模型名称:', modelName);
        return;
      }
      try {
        updateModelInfo(modelName, '正在加载...');
        clearCurrentModel();
        if (loadingText) {
          loadingText.style.display = 'block';
          loadingText.textContent = '正在加载模型...';
        }
        if (!container.contains(app.view)) {
          container.appendChild(app.view);
        }
        const config = modelConfigs[modelName];
        const loader = new PIXI.Loader();
        const encodedSkelUrl = encodePathSegments(config.skelFile);
        const customImageLoaderFactory = function(ldr, namePrefix, baseUrl, imageOptions) {
          if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
            baseUrl += '/';
          }
          return function(line, callback) {
            const name = namePrefix + line;
            const encodedLine = line.split('/').map(encodeURIComponent).join('/');
            const url = baseUrl + encodedLine;
            const cachedResource = ldr.resources[name];
            if (cachedResource) {
              const done = () => {
                callback(cachedResource.texture.baseTexture);
              };
              if (cachedResource.texture) {
                done();
              } else {
                cachedResource.onAfterMiddleware.add(done);
              }
            } else {
              ldr.add(name, url, imageOptions, (resource) => {
                if (!resource.error) {
                  if (line.indexOf('-pma.') >= 0 && PIXI.ALPHA_MODES && resource.texture && resource.texture.baseTexture) {
                    resource.texture.baseTexture.alphaMode = PIXI.ALPHA_MODES.PMA;
                  }
                  callback(resource.texture.baseTexture);
                } else {
                  callback(null);
                }
              });
            }
          }
        };
        loader.add(modelName, encodedSkelUrl, {
          metadata: {
            imageLoader: customImageLoaderFactory
          }
        });
        loader.load((loader, resources) => {
          try {
            if (!resources[modelName] || !resources[modelName].spineData) {
              throw new Error('Spine数据加载失败');
            }
            if (loadingText) loadingText.style.display = 'none';
            currentSpine = new PIXI.spine.Spine(resources[modelName].spineData);
            currentSpine.x = app.screen.width / 2;
            currentSpine.y = app.screen.height / 2;
            const bounds = currentSpine.getBounds();
            const scaleX = (app.screen.width * 0.3) / bounds.width;
            const scaleY = (app.screen.height * 0.3) / bounds.height;
             const baseScale = Math.min(scaleX, scaleY);
             const isNumberStartWithHash = config && config.name && /^\d.*#/.test(config.name);
             const allowUpscale = (config && config.allowUpscale) || isNumberStartWithHash;
             const scale = allowUpscale ? Math.min(baseScale, 1.5) : Math.min(baseScale, 1);
             currentSpine.scale.set(scale);
            currentSpine.x = app.screen.width / 2;
            currentSpine.y = app.screen.height; // 初始就落地
            app.stage.addChild(currentSpine);
            currentSpine.interactive = true;
            currentSpine.buttonMode = true;
            currentSpine.on('click', handleMouseClick);
            currentSpine.on('pointerdown', startDrag);
            isOnGround = true;
            const animationSelect = document.getElementById('animation-select');
            animationSelect.innerHTML = '<option value="">选择动作...</option>';
            if (currentSpine.state.data.skeletonData.animations.length > 0) {
              currentSpine.state.data.skeletonData.animations.forEach(animation => {
                const option = document.createElement('option');
                option.value = animation.name;
                option.textContent = animation.name;
                animationSelect.appendChild(option);
              });
              let defaultAnimation = currentSpine.state.data.skeletonData.animations.find(anim => 
                anim.name.toLowerCase().includes('move') || anim.name.toLowerCase().includes('walk')
              );
              if (!defaultAnimation) {
                defaultAnimation = currentSpine.state.data.skeletonData.animations[0];
              }
              currentSpine.state.setAnimation(0, defaultAnimation.name, true);
              animationSelect.value = defaultAnimation.name;
              originalAnimation = defaultAnimation.name;
              isPlaying = true;
              isMoving = true;
              startMoving();
            }
            updateModelInfo(modelName, '加载成功');
            console.log('Spine模型加载成功！');
          } catch (e) {
            console.error('创建Spine对象时出错:', e);
            updateModelInfo(modelName, '加载失败');
            if (loadingText) {
              loadingText.style.display = 'block';
              loadingText.textContent = '错误: ' + (e && e.message ? e.message : '未知错误');
            }
          }
        });
      } catch (error) {
        console.error('加载Spine模型时出错:', error);
        updateModelInfo(modelName, '加载失败');
        if (loadingText) {
          loadingText.style.display = 'block';
          loadingText.textContent = '错误: ' + (error && error.message ? error.message : '未知错误');
        }
      }
    }
    
    function initializeEventListeners() {
      const modelSelect = document.getElementById('model-select');
      modelSelect.addEventListener('change', function() {
        if (this.value) {
          loadSpineModel(this.value);
        } else {
          clearCurrentModel();
          updateModelInfo(null, '等待选择');
        }
      });
      
      // 动画选择事件监听器
      const animationSelect = document.getElementById('animation-select');
      animationSelect.addEventListener('change', function() {
        if (this.value && currentSpine) {
          currentSpine.state.setAnimation(0, this.value, true);
          isPlaying = true;
          console.log('切换到动画:', this.value);
        }
      });
      
      // 播放/暂停按钮事件监听器
      const playPauseBtn = document.getElementById('play-pause-btn');
      playPauseBtn.addEventListener('click', function() {
        if (currentSpine && currentSpine.state.tracks[0]) {
          if (isPlaying) {
            currentSpine.state.tracks[0].timeScale = 0; // 暂停动画
            stopMoving(); // 停止移动
            console.log('动画和移动已暂停');
          } else {
            currentSpine.state.tracks[0].timeScale = 1; // 播放动画
            isMoving = true;
            startMoving(); // 开始移动
            console.log('动画和移动已播放');
          }
          isPlaying = !isPlaying;
        }
      });
    }
    
    // 页面加载完成后初始化
    window.addEventListener('load', () => {
      // 添加canvas到容器
      container.appendChild(app.view);

      // 初始化事件监听器
      initializeEventListeners();

      // 全局舞台拖拽事件
      app.stage.interactive = true;
      app.stage.on('pointermove', onDragMove);
      app.stage.on('pointerup', endDrag);
      app.stage.on('pointerupoutside', endDrag);

      // 自适应窗口尺寸
      window.addEventListener('resize', () => {
        app.renderer.resize(window.innerWidth, window.innerHeight);
        // 保持落地与边界
        if (currentSpine) {
          if (isOnGround) currentSpine.y = app.screen.height;
          // 限制到新宽度范围内
          currentSpine.x = Math.max(0, Math.min(app.screen.width, currentSpine.x));
        }
        // 更新描边像素尺寸
        if (dragOutlineFilter) {
          dragOutlineFilter.uniforms.pixelSize = new Float32Array([1 / app.screen.width, 1 / app.screen.height]);
        }
      });

      // 初始化模型信息
      updateModelInfo(null, '等待选择');

      console.log('Spine模型查看器初始化完成');
    });
    
    // 错误处理
    window.addEventListener('error', (event) => {
      console.error('页面错误:', event.error);
    });
  </script>
</body>
</html>